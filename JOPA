An idea of the new kernel language, a lispy one
JOPA: Joys Of Partial Application
It is smaller syntactically and it can be parsed without LEPL

Syntax rules:
1) Braces
2) Whitespace

Braces (f a b c) means:
	Take a function f
	call it with value a,
	call the result with the value b,
	call the result with the value c,
	stop and return
Empty braces () means None
(f) means f

Whitespace separates stuff inside braces

There is no special syntax for 'do not evaluate' like the Lisp's quote.

!) IMPORTANT A function does not get its parameter preevaluated.
What it gets is either an identifier (a string) or a brace (a code block)
The function decides whether to evaluate a brace or an identifier

(
 xslang io print (
  xslang string create Hello, (xslang string space) World!
 )
)
(xslang string create Hello,) creates a string. Applying parameters to a string
results in concatenations.

(
 xslang operator last
 (xslang context set int (xslang int))
 ((int +) (int 3) (int 2))
 (xslang operator prefix int + 3 2)
)
Here (xslang operator last) is a function that returns the last element

(
 xslang operator last
 (xslang context set ident (xslang function of y y))
 (ident xslang)
)
Here ident is a function awaiting an argument. when it's called, y gets
injected into the namespace and the evaluation happens.

Approximate mappings with xslang-core:
{ abc }				<=>	(xslang function block (abc))
{ x | x }			<=>	(xslang function of x x)
'Hello!'			<=>	(xslang string create Hello!)
{ x | x }()			<=>	(xslang function of x x ())
{ x | x }('a')			<=>	(xslang function of x x ('a'))
a.b				<=>	(xslang inspect a b)
a;b				<=>	(xslang operator last a b)
xslang.context.set('a')(b)	<=>	(xslang context set a b)

